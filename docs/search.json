[{"path":"index.html","id":"introduction","chapter":"Introduction","heading":"Introduction","text":"","code":""},{"path":"index.html","id":"reproducible-analysis","chapter":"Introduction","heading":"0.1 Reproducible analysis","text":"entire analysis contained book can reproduced running following function bookdown package.may necessary install additional packages make use bs4_book template book.","code":"\nbookdown::render_book(\"index.Rmd\")\ninstall.packages(\"remotes\")\nremotes::install_github(\"rstudio/bslib\")\ninstall.packages(\"downlit\")"},{"path":"gee-harmonic-regression.html","id":"gee-harmonic-regression","chapter":"1 GEE: Harmonic Regression","heading":"1 GEE: Harmonic Regression","text":"project want explore degree environmental predictability can explain species declines among sub-Saharan migrant songbirds. define environmental predictability degree simple harmonic regression model can fit seasonal changes environmental variables wintering areas sub-Saharan migrants.able run harmonic time series analysis fine-scale across full extent wintering ranges birds, use Google Earth Engine (GEE).","code":""},{"path":"gee-harmonic-regression.html","id":"apply-harmonic-regression-to-gee-datasets","chapter":"1 GEE: Harmonic Regression","heading":"1.1 Apply harmonic regression to GEE datasets","text":"function R/rgee_harmonic_regression.R contains code necessary run harmonic regression GEE using rgee package. export harmonic regression results 10km resolution limit spatial domain following area.Obviously area spans much just Africa, interpretation results (possible future expansion analysis include breeding areas), beneficial.can now run harmonic regression GEE generate GeoTIFFs analyses. particularly interested NDVI use temporal range NASA/GIMMS/3GV0 dataset (GEE) determine time frame run analysis.","code":"\naoi <- read_sf(\"data/raw/studyarea.geojson\")\nleaflet(aoi) %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  addPolygons(color = \"black\")\nsource(\"R/rgee_harmonic_regression.R\")\n\nres <- 10000\n\nndvi1 <- rgee_harmonic_regression(dataset = \"NASA/GIMMS/3GV0\", dependent = \"ndvi\", harmonics = 1, \n                                  aoi = aoi, resolution = res, dsn = \"data/raw/gee/ndvi_1.tif\", mask = -1)\nndvi2 <- rgee_harmonic_regression(dataset = \"NASA/GIMMS/3GV0\", dependent = \"ndvi\", harmonics = 2,\n                                  aoi = aoi, resolution = res, dsn = \"data/raw/gee/ndvi_2.tif\", mask = -1)\naet1 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"aet\", harmonics = 1,\n                                 aoi = aoi, resolution = res, dsn = \"data/raw/gee/aet_1.tif\",\n                                 refdataset = \"NASA/GIMMS/3GV0\")\naet2 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"aet\", harmonics = 2,\n                                 aoi = aoi, resolution = res, dsn = \"data/raw/gee/aet_2.tif\",\n                                 refdataset = \"NASA/GIMMS/3GV0\")\npet1 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"pet\", harmonics = 1,\n                                 aoi = aoi, resolution = res, dsn = \"data/raw/gee/pet_1.tif\",\n                                 refdataset = \"NASA/GIMMS/3GV0\")\npet2 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"pet\", harmonics = 2,\n                                 aoi = aoi, resolution = res, dsn = \"data/raw/gee/pet_2.tif\",\n                                 refdataset = \"NASA/GIMMS/3GV0\")\npr1 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"pr\", harmonics = 1,\n                                aoi = aoi, resolution = res, dsn = \"data/raw/gee/pr_1.tif\",\n                                refdataset = \"NASA/GIMMS/3GV0\")\npr2 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"pr\", harmonics = 2,\n                                aoi = aoi, resolution = res, dsn = \"data/raw/gee/pr_2.tif\",\n                                refdataset = \"NASA/GIMMS/3GV0\")\ntmmn1 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"tmmn\", harmonics = 1,\n                                  aoi = aoi, resolution = res, dsn = \"data/raw/gee/tmmn_1.tif\",\n                                  refdataset = \"NASA/GIMMS/3GV0\")\ntmmn2 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"tmmn\", harmonics = 2,\n                                  aoi = aoi, resolution = res, dsn = \"data/raw/gee/tmmn_2.tif\",\n                                  refdataset = \"NASA/GIMMS/3GV0\")\ntmmx1 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"tmmx\", harmonics = 1,\n                                  aoi = aoi, resolution = res, dsn = \"data/raw/gee/tmmx_1.tif\",\n                                  refdataset = \"NASA/GIMMS/3GV0\")\ntmmx2 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"tmmx\", harmonics = 2,\n                                  aoi = aoi, resolution = res, dsn = \"data/raw/gee/tmmx_2.tif\",\n                                  refdataset = \"NASA/GIMMS/3GV0\")\ndef1 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"def\", harmonics = 1,\n                                 aoi = aoi, resolution = res, dsn = \"data/raw/gee/def_1.tif\",\n                                 refdataset = \"NASA/GIMMS/3GV0\")\ndef2 <- rgee_harmonic_regression(dataset = \"IDAHO_EPSCOR/TERRACLIMATE\", dependent = \"def\", harmonics = 2,\n                                 aoi = aoi, resolution = res, dsn = \"data/raw/gee/def_2.tif\",\n                                 refdataset = \"NASA/GIMMS/3GV0\")"},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"preprocess-bird-trends-and-distribution-maps","chapter":"2 Preprocess bird trends and distribution maps","heading":"2 Preprocess bird trends and distribution maps","text":"","code":""},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"converting-the-esri-geodatabase","chapter":"2 Preprocess bird trends and distribution maps","heading":"2.1 Converting the ESRI Geodatabase","text":"use BirdLife species distribution maps1 determine extents analyses. data provided ESRI File Geodatabase somehow difficult query due size, convert Geopackage first. file substantially bigger, much quicker query.","code":"\nogr2ogr(\"data/raw/birdlife/BOTW.gdb\", \"data/raw/birdlife/BOTW.gpkg\", f = \"GPKG\", nlt = \"MULTIPOLYGON\", sql = \"SELECT * FROM All_Species\", progress = TRUE)"},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"load-species-trends","chapter":"2 Preprocess bird trends and distribution maps","heading":"2.2 Load species trends","text":"use species trends derived PECBMS, Pan-European Common Bird Monitoring Scheme, contains trends 179 European breeding birds.","code":"\ncolnames_species <- c(\"euring\", \"species\", \"namenote\", \"trend_long\", \"trend_short\", \"trend_long_slope\",\n                      \"trend_long_se\", \"trend_short_slope\", \"trend_short_se\", \"habitat\", \"common_name\",\n                      \"trend_classification\", \"graphnote\")\ncoltypes_species <- \"ncnnnnnnncccc\"\n\nspecies <- read_delim(\"data/raw/pecbms/pecbms-europe-indicesandtrends-2019.csv\", delim = \";\", \n                      col_names = colnames_species, col_types = coltypes_species, skip = 1)\nhead(species)"},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"loading-species-traits","chapter":"2 Preprocess bird trends and distribution maps","heading":"2.3 Loading species traits","text":"download dataset life-history characteristics (LHC) Storchová & Hořák.2We can now load dataset extract species name migratory characteristics, can filter latter later.add species trends life-history characteristics single dataframe.can inspect species migration strategy found yet mismatching species name-pairs. species NA values family column.can now manually change scientific names life-history characteristics dataset match PECBMS dataset.join LHC PECBMS datasets.","code":"\nif (!file.exists(\"data/raw/life-history-characteristics/Life-history characteristics of European birds.txt\")) {\n  paths_cache <- dryad_download(\"10.5061/dryad.n6k3n\")[[1]]\n  paths_final <- paste0(\"data/raw/life-history-characteristics/\", basename(paths_cache))\n  \n  if(!dir.exists(\"data/raw/life-history-characteristics\")) {\n    dir.create(\"data/raw/life-history-characteristics\")\n  }\n  file.copy(from = paths_cache, to = paths_final)\n  file.remove(paths_cache)\n}\nlhc <- read_tsv(\"data/raw/life-history-characteristics/Life-history characteristics of European birds.txt\",\n                col_types = cols_only(`Species` = col_character(), `Family` = col_character(),\n                                      `Sedentary` = col_double(), `Facultative migrant` = col_double(),\n                                      `Short distance migrant` = col_double(), `Long distance migrant` = col_double())) %>%\n  rename(species = Species, family = Family, sedentary = Sedentary, facultative = `Facultative migrant`, \n         shortdist = `Short distance migrant`, longdist = `Long distance migrant`) %>%\n  drop_na()\nspecies %>%\n  left_join(lhc, by = c(\"species\" = \"species\")) -> species\nspecies %>%\n  filter(is.na(family)) %>%\n  head()\nname_replacements <-\n  c(\"Ptyonoprogne rupestris\" = \"Hirundo rupestris\",\n    \"Cecropis daurica\" = \"Hirundo daurica\",\n    \"Cyanecula svecica\" = \"Luscinia svecica\",\n    \"Oenanthe pleschanka\" = \"Oenanthe cypriaca\",\n    \"Iduna pallida\" = \"Hippolais pallida\",\n    \"Sylvia melanothorax\" = \"Sylvia melanothorax\",  # Not in LHC dataset\n    \"Poecile palustris\" = \"Parus palustris\",\n    \"Poecile montanus\" = \"Parus montanus\",\n    \"Lophophanes cristatus\" = \"Parus cristatus\",\n    \"Periparus ater\" = \"Parus ater\",\n    \"Cyanistes caeruleus\" = \"Parus caeruleus\",\n    \"Chloris chloris\" = \"Carduelis chloris\",\n    \"Spinus spinus\" = \"Carduelis spinus\",\n    \"Linaria cannabina\" = \"Carduelis cannabina\",\n    \"Acanthis flammea\" = \"Carduelis flammea\",\n    \"Emberiza calandra\" = \"Miliaria calandra\"\n    )\nspeciesnames <- lhc$species\noldnames <- speciesnames\nfor (name in names(name_replacements)) {\n  speciesnames <- replace(speciesnames, which(speciesnames == name), name_replacements[name])\n}\nlhc$species <- speciesnames\nspecies %>%\n  dplyr::select(-colnames(lhc)[!colnames(lhc) %in% c(\"species\")]) %>%\n  left_join(lhc, by = c(\"species\" = \"species\")) %>%\n  drop_na(family) %>%\n  identity() -> species\n\nhead(species)"},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"select-migratory-species","chapter":"2 Preprocess bird trends and distribution maps","heading":"2.4 Select migratory species","text":"now dataset 169 species, merely interested actually migratory, filter resident facultative migrants.","code":"\nspecies %>%\n  filter(sedentary != 1 & facultative != 1) -> species\n\nhead(species)"},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"match-names-to-birdlife-taxonomy","chapter":"2 Preprocess bird trends and distribution maps","heading":"2.5 Match names to BirdLife taxonomy","text":"Finally, querying BirdLife distribution maps, match scientific names taxonomy used BirdLife., see species matched tweak manually match BirdLife dataset.tweak species manually.","code":"\nbirdlife_taxonomy <- readxl::read_excel(\"data/raw/birdlife/HBW-BirdLife_List_of_Birds_v4.xlsx\", \n                                        col_names = c(\"family_birdlife\", \"common_name_birdlife\", \"species\", \"iucn_redlist\"))\n\nspecies %>%\n  left_join(birdlife_taxonomy, by = c(\"species\" = \"species\")) -> species\nspecies %>%\n  filter(is.na(family_birdlife)) %>%\n  head()\nname_replacements_birdlife <-\n  c(\"Hirundo daurica\" = \"Cecropis daurica\",\n    \"Luscinia svecica\" = \"Cyanecula svecica\",\n    \"Hippolais pallida\" = \"Iduna pallida\",\n    \"Carduelis spinus\" = \"Spinus spinus\",\n    \"Carduelis flammea\" = \"Acanthis flammea\"\n    )\nspeciesnames <- species$species\noldnames <- speciesnames\nfor (name in names(name_replacements_birdlife)) {\n  speciesnames <- replace(speciesnames, which(speciesnames == name), name_replacements_birdlife[name])\n}\nspecies$species_birdlife <- speciesnames"},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"querying-distribution-maps","chapter":"2 Preprocess bird trends and distribution maps","heading":"2.6 Querying distribution maps","text":"Now gathered species trends selected migratory species, can query database select corresponding distribution maps. species distributed massive areas, select parts distributions intersect bounding box Africa.can now join datasets save upcoming analysis steps.","code":"\nspecies_query <- str_sub(str_replace_all(toString(paste0(\"SCINAME = '\", species$species_birdlife, \"' OR \")), \" OR , \", \" OR \"),\n                         start = 1, end = -5)\nquery <- paste(\"SELECT * FROM All_Species WHERE (\", species_query, \") AND PRESENCE = 1 AND SEASONAL = 3\", sep = \"\")\n\nafrica <- st_read(\"data/raw/Africa.gpkg\")\n\nogr2ogr(\"data/raw/birdlife/BOTW.gpkg\", \"data/processed/TrendSpecies.gpkg\", sql = query, f = \"GPKG\", nlt = \"MULTIPOLYGON\", progress = TRUE,\n        spat = st_bbox(africa))\nst_read(\"data/processed/TrendSpecies.gpkg\") %>%\n  group_by(SCINAME) %>%\n  summarise(species = SCINAME, geometry = st_union(st_buffer(geom, dist = 0))) %>%\n  distinct(species) %>%\n  left_join(species, by = c(\"species\" = \"species\")) %>%\n  identity() -> trendspecies\n\nsaveRDS(trendspecies, file = \"data/processed/trendspecies.RDS\")"},{"path":"preprocess-bird-trends-and-distribution-maps.html","id":"species-included-in-the-analysis","chapter":"2 Preprocess bird trends and distribution maps","heading":"2.7 Species included in the analysis","text":"Finally following species now included analysis, based distribution ranges migratory behavior.","code":"\nreadRDS(\"data/processed/trendspecies.RDS\") %>% \n  st_drop_geometry() %>%\n  ungroup() %>%\n  dplyr::select(species, common_name_birdlife) %>%\n  rename(`Scientific name` = species, `Common name (BirdLife)` = common_name_birdlife)"},{"path":"species-assemblage-trends.html","id":"species-assemblage-trends","chapter":"3 Species assemblage trends","heading":"3 Species assemblage trends","text":"study follow methodology Beresford et al. 3 calculate assemblage trend across entire study area. assume environmental factors wintering areas (case Africa) play role towards influencing species trends, areas assemblage trends (product individual species trends) higher likely provide beneficial environmental factors vice versa.","code":""},{"path":"species-assemblage-trends.html","id":"calculate-assemblage-trends","chapter":"3 Species assemblage trends","heading":"3.1 Calculate assemblage trends","text":"calculate long- short-term assemblage trends based PECBMS long-term short-term trends. use raster NDVI predictability template project values onto. Additionally, calculate number species occur within assemblages.","code":"\ntrendspecies <- readRDS(\"data/processed/trendspecies.RDS\")\n\ntrend_long_raster <- list()\ntrend_short_raster <- list()\n\ntemplate_raster <- raster::raster(\"data/raw/gee/ndvi_1.tif\")\n\n# Rasterize distribution maps of individual species and assign trend to pixel values\nfor (i in 1:nrow(trendspecies)) {\n  trend_long_raster[[i]] <- fasterize(trendspecies[i, ], raster = template_raster, field = \"trend_long\")\n  trend_short_raster[[i]] <- fasterize(trendspecies[i, ], raster = template_raster, field = \"trend_short\")\n}\n\n# Turn list of rasters into raster bricks for calculations\ntrend_long_raster <- suppressWarnings(brick(trend_long_raster))\ntrend_short_raster <- suppressWarnings(brick(trend_short_raster))\nnames(trend_long_raster) <- trendspecies[, \"species\"]$species\nnames(trend_short_raster) <- trendspecies[, \"species\"]$species\n\n# Calculate assemblage trend\ntrend_long_assemblage <- calc(trend_long_raster, mean, na.rm = TRUE)\ntrend_short_assemblage <- calc(trend_short_raster, mean, na.rm = TRUE)\n\n# Reclassify trends to NA or 1\ntrend_long_counts <- suppressWarnings(reclassify(trend_long_raster, c(-Inf, Inf, 1)))\ntrend_short_counts <- suppressWarnings(reclassify(trend_short_raster, c(-Inf, Inf, 1)))\n\n# Calculate number of species that make up an assemblage\ntrend_long_counts <- calc(trend_long_counts, sum, na.rm = TRUE)\ntrend_short_counts <- calc(trend_short_counts, sum, na.rm = TRUE)\n\n# Write rasters to files\nwriteRaster(trend_long_assemblage, file = \"data/processed/trend_long_assemblage.tif\", overwrite = TRUE)\nwriteRaster(trend_short_assemblage, file = \"data/processed/trend_short_assemblage.tif\", overwrite = TRUE)\nwriteRaster(trend_long_counts, file = \"data/processed/trend_long_counts.tif\", overwrite = TRUE)\nwriteRaster(trend_short_counts, file = \"data/processed/trend_short_counts.tif\", overwrite = TRUE)"},{"path":"species-assemblage-trends.html","id":"plot-assemblage-trends","chapter":"3 Species assemblage trends","heading":"3.2 Plot assemblage trends","text":"Let’s make quick plot assemblage trends side side","code":"\npar(mfrow = c(1, 2))\nplot(trend_long_assemblage, main = \"Long-term assemblage trend\")\nplot(trend_short_assemblage, main = \"Short-term assemblage trend\")\npar(mfrow = c(1, 2))\nplot(trend_long_counts, main = \"# spp. in long-term assemblage\")\nplot(trend_short_counts, main = \"# spp. in short-term assemblage\")"},{"path":"ecoregions-biomes.html","id":"ecoregions-biomes","chapter":"4 Ecoregions & Biomes","heading":"4 Ecoregions & Biomes","text":"Environmental long-term trends predictability may difference influence assemblage trends across different ecoregions biomes. One can, example, imagine arid regions predictability precipitation important predictor assemblage trend regions see much precipitation annually, regardless predictable happens .account possible variation, download dataset ecoregions biomes, add dataset.now rasterize realms, biomes ecoregions later add stars object created previous chapters.Let’s see worked intended.previous steps result RasterBrick layers contain NAs, throw reduce memory footprint datasets. ’re , save rasterized polygons GeoTIFF file.Rasterizing ecoregion polygons removes ‘elegant’ names corresponding areas, save lookup table convert necessary later .","code":"\ntemplate_raster <- raster::raster(\"data/raw/gee/ndvi_1.tif\")\nafrica <- st_read(\"data/raw/Africa.gpkg\")\n\necoregions <- st_read(\"data/raw/ecoregions2017/Ecoregions2017.shp\") %>%\n  dplyr::select(ECO_NAME, BIOME_NAME, REALM) %>%\n  st_crop(africa)## although coordinates are longitude/latitude, st_intersection assumes that they are planar## Warning: attribute variables are assumed to be spatially constant throughout all\n## geometries\nsaveRDS(ecoregions, file = \"data/processed/ecoregions.RDS\")## Reading layer `Africa-Dissolved' from data source `/mnt/envirpred/raw/Africa.gpkg' using driver `GPKG'\n## Simple feature collection with 1 feature and 2 fields\n## geometry type:  MULTIPOLYGON\n## dimension:      XY\n## bbox:           xmin: -25.3618 ymin: -50.01889 xmax: 77.60327 ymax: 37.55986\n## CRS:            4326\n## Reading layer `Ecoregions2017' from data source `/mnt/envirpred/raw/ecoregions2017/Ecoregions2017.shp' using driver `ESRI Shapefile'\n## Simple feature collection with 847 features and 15 fields\n## geometry type:  MULTIPOLYGON\n## dimension:      XY\n## bbox:           xmin: -180 ymin: -89.89197 xmax: 180 ymax: 83.62313\n## CRS:            4326\necoregions <- readRDS(\"data/processed/ecoregions.RDS\")\n\nr_realms <- fasterize(st_collection_extract(ecoregions, type = \"POLYGON\"), template_raster, by = \"REALM\")\nr_biomes <- fasterize(st_collection_extract(ecoregions, type = \"POLYGON\"), template_raster, by = \"BIOME_NAME\")\nr_ecoregions <- fasterize(st_collection_extract(ecoregions, type = \"POLYGON\"), template_raster, by = \"ECO_NAME\")\nplot(r_realms, 1:2)\nempty_raster <- function(r) {\n  nr_NAs <- cellStats(is.na(r), sum)\n  if (ncell(r) == nr_NAs) { TRUE } \n  else { FALSE }\n}\n\nempty_layers <- function(b) {\n  idx <- c()\n  for (i in 1:nlayers(b)) {\n    if (empty_raster(b[[i]])) {\n      idx <- c(idx, TRUE)\n    } else {\n      idx <- c(idx, FALSE)\n    }\n  }\n  idx\n}\n\nr_realms <- suppressWarnings(subset(r_realms, which(!empty_layers(r_realms))))\nr_biomes <- suppressWarnings(subset(r_biomes, which(!empty_layers(r_biomes))))\nr_ecoregions <- suppressWarnings(subset(r_ecoregions, which(!empty_layers(r_ecoregions))))\n\nwriteRaster(r_realms, filename = \"data/processed/realms.tif\", overwrite = TRUE, format = \"GTiff\")\nwriteRaster(r_biomes, filename = \"data/processed/biomes.tif\", overwrite = TRUE, format = \"GTiff\")\nwriteRaster(r_ecoregions, filename = \"data/processed/ecoregions.tif\", overwrite = TRUE, format = \"GTiff\")\nname_lookup <- function(r_names, sf_names, suffix) {\n  r_names <- data.frame(name = r_names, stringsAsFactors = FALSE)\n  sf_names <- data.frame(orig_name = as.character(droplevels(sf_names)), stringsAsFactors = FALSE)\n  sf_names$name <- str_replace_all(sf_names$orig_name, c(\" \" = \".\", \"&\" = \".\", \",\" = \".\", \"-\" = \".\"))\n  \n  raster_name <- paste0(\"raster_name\", suffix)\n  orig_name <- paste0(\"orig_name\", suffix)\n  \n  df <- left_join(r_names, sf_names, by = \"name\")\n  colnames(df) <- c(raster_name, orig_name)\n  df\n}\n\necoregs <- name_lookup(names(r_ecoregions), ecoregions$ECO_NAME, \"_ecoreg\")\nrealms <- name_lookup(names(r_realms), ecoregions$REALM, \"_realm\")\nbiomes <- name_lookup(names(r_biomes), ecoregions$BIOME_NAME, \"_biome\")\n\nlut <- list(names(r_ecoregions), ecoregs, names(r_realms), realms, names(r_biomes), biomes)\nnames(lut) <- c(\"ecoregions\", \"lut_ecoregions\", \"realms\", \"lut_realms\", \"biomes\", \"lut_biomes\")\nsaveRDS(lut, file = \"data/processed/ecoregions_lut.RDS\")"},{"path":"environmental-predictability-trends.html","id":"environmental-predictability-trends","chapter":"5 Environmental predictability & trends","heading":"5 Environmental predictability & trends","text":"applied harmonic regression datasets containing following variables:NDVI Normalized Difference Vegetation Index GIMMS NDVI AVHRR Sensors 3rd Generation datasetAET Actual Evapotranspiration TerraClimate datasetPR Precipitation accumulation TerraClimate datasetTMMX Maximum temperature TerraClimate datasetTMMN Minimum temperature TerraClimate datasetAll datasets contain monthly aggregates.","code":""},{"path":"environmental-predictability-trends.html","id":"combine-environmental-datasets-trend-datasets-and-ecoregions","chapter":"5 Environmental predictability & trends","heading":"5.1 Combine environmental datasets, trend datasets and ecoregions","text":"need combine predictors (environmental factors) response (assemblage trends) single dataset modelling. also limit data spatially outline African continent (including Madagascar).confirm worked, let’s plot output.","code":"\nafrica_outline <- st_read(\"data/raw/Africa.gpkg\")\nlut <- readRDS(\"data/processed/ecoregions_lut.RDS\")\n\nload_raster <- function(rasterpath, bandnames) {\n  r <- stack(rasterpath)\n  if (!is.null(bandnames)) {\n    band_ids <- which(names(r) %in% bandnames)\n    lapply(band_ids, function(x) raster(rasterpath, band = x))\n  } else {\n    unstack(r)\n  }\n}\n\nndvi <- load_raster(\"data/raw/gee/ndvi_1.tif\", c(\"ndvi_original\", \"residuals\", \"slope\"))\npr <- load_raster(\"data/raw/gee/pr_1.tif\", c(\"pr_original\", \"residuals\", \"slope\"))\npet <- load_raster(\"data/raw/gee/pet_1.tif\", c(\"pet_original\", \"residuals\", \"slope\"))\naet <- load_raster(\"data/raw/gee/aet_1.tif\", c(\"aet_original\", \"residuals\", \"slope\"))\ntmmn <- load_raster(\"data/raw/gee/tmmn_1.tif\", c(\"tmmn_original\", \"residuals\", \"slope\"))\ntmmx <- load_raster(\"data/raw/gee/tmmx_1.tif\", c(\"tmmx_original\", \"residuals\", \"slope\"))\ndef <- load_raster(\"data/raw/gee/def_1.tif\", c(\"def_original\", \"residuals\", \"slope\"))\nrealms <- load_raster(\"data/processed/realms.tif\", NULL)\nbiomes <- load_raster(\"data/processed/biomes.tif\", NULL)\n\ntrend_long_assemblage <- raster::raster(\"data/processed/trend_long_assemblage.tif\")\ntrend_short_assemblage <- raster::raster(\"data/processed/trend_short_assemblage.tif\")\ntrend_long_counts <- raster::raster(\"data/processed/trend_long_counts.tif\")\ntrend_short_counts <- raster::raster(\"data/processed/trend_short_counts.tif\")\n\nbandnames <- c(\"ndvi\", \"ndvi_resid\", \"ndvi_trend\", \"pr\", \"pr_resid\", \"pr_trend\", \"pet\", \"pet_resid\", \"pet_trend\", \n               \"aet\", \"aet_resid\",\"aet_trend\", \"tmmn\", \"tmmn_resid\", \"tmmn_trend\", \"tmmx\", \"tmmx_resid\", \"tmmx_trend\", \n               \"def\", \"def_resid\", \"def_trend\", \"trend_long\", \"trend_short\", \"count_long\", \"count_short\",\n               lut$realms, lut$biomes)\n\ndata <- suppressWarnings(brick(c(ndvi, pr, pet, aet, tmmn, tmmx, def, trend_long_assemblage, trend_short_assemblage, \n                                 trend_long_counts, trend_short_counts, realms, biomes)))\nnames(data) <- bandnames\n\ndata_stars <- st_as_stars(data)[africa_outline] %>%\n  st_set_dimensions(3, values = bandnames) %>%\n  st_set_dimensions(names = c(\"x\", \"y\", \"var\"))## although coordinates are longitude/latitude, st_intersects assumes that they are planar## Reading layer `Africa-Dissolved' from data source `/mnt/envirpred/raw/Africa.gpkg' using driver `GPKG'\n## Simple feature collection with 1 feature and 2 fields\n## geometry type:  MULTIPOLYGON\n## dimension:      XY\n## bbox:           xmin: -25.3618 ymin: -50.01889 xmax: 77.60327 ymax: 37.55986\n## CRS:            4326\nplot(data_stars)"},{"path":"environmental-predictability-trends.html","id":"save-modeling-dataset","chapter":"5 Environmental predictability & trends","heading":"5.2 Save modeling dataset","text":"now save stars brick dataframe modeling.","code":"\nsaveRDS(data_stars, file = \"data/processed/data_stars.RDS\")\n\nas.data.frame(data_stars) %>%\n  `colnames<-`(c(\"x\", \"y\", \"variable\", \"value\")) %>%\n  pivot_wider(names_from = variable, values_from = value) %>%\n  drop_na(!any_of(c(lut$ecoregions, lut$realms, lut$biomes))) %>%\n  identity() -> data\n\nsaveRDS(data, file = \"data/processed/data.RDS\")"},{"path":"global-model.html","id":"global-model","chapter":"6 Global model","heading":"6 Global model","text":"previous chapters prepared dataset modelling, can now start use.","code":""},{"path":"global-model.html","id":"correlation-among-predictors","chapter":"6 Global model","heading":"6.1 Correlation among predictors","text":"first assess correlations among predictors. intend compare models using environmental predictability long-term trends separate correlation matrices .","code":""},{"path":"global-model.html","id":"pearsons-correlation-matrix","chapter":"6 Global model","heading":"6.1.1 Pearson’s correlation matrix","text":"indicates environmental residuals generally correlated strongly long-term trends. covariates, def, tmmx tmmn strongly correlated variables. can reduce correlation temperature measures calculating average temperature tmmx tmmn remove def modeling dataset.calculate new correlation matrix.continue see strong correlation pr_resid ndvi_resid, original variables (ndvi pr) effectively uncorrelated ndvi_trend pr_trend want trends predictability model comparable, keep .","code":"\nunused_predictors <- c(\"trend_long\", \"trend_short\", \"count_long\", \"count_short\",\n                       \"def\", \"tmmx\", \"tmmn\", \"aet\", \"pet\", \"pr\", \"ndvi\", \"x\", \"y\",\n                       lut$ecoregions, lut$biomes, lut$realms)\npredictors <- colnames(data)[!colnames(data) %in% unused_predictors]\npredictors_trends <- colnames(dplyr::select(data, ends_with(\"_trend\")))\npredictors_resids <- colnames(dplyr::select(data, ends_with(\"_resid\")))\n\nggcorrmat(data, cor.vars = all_of(predictors_trends), type = \"parametric\")\nggcorrmat(data, cor.vars = all_of(predictors_resids), type = \"parametric\")\ndata %>%\n  rowwise() %>%\n  mutate(tm_trend = mean(c(tmmx_trend, tmmn_trend)),\n         tm_resid = mean(c(tmmx_resid, tmmn_resid))) %>%\n  ungroup() %>%\n  identity() -> data\npredictors_trends <- c(predictors_trends[!predictors_trends %in% c(\"tmmx_trend\", \"tmmn_trend\", \"def_trend\")], \"tm_trend\")\npredictors_resids <- c(predictors_resids[!predictors_resids %in% c(\"tmmx_resid\", \"tmmn_resid\", \"def_resid\")], \"tm_resid\")\nggcorrmat(data, cor.vars = all_of(predictors_trends), type = \"parametric\")\nggcorrmat(data, cor.vars = all_of(predictors_resids), type = \"parametric\")"},{"path":"global-model.html","id":"pairplot","chapter":"6 Global model","heading":"6.2 Pairplot","text":"’re , ’s useful make pairplot predictor variables.","code":"\ndata %>%\n  slice_sample(n = 1000) -> data_tiny\n\nggpairs(data_tiny, columns = all_of(c(predictors_trends, \"trend_long\")), progress = FALSE)\nggpairs(data_tiny, columns = all_of(c(predictors_resids, \"trend_long\")), progress = FALSE)"},{"path":"global-model.html","id":"optimal-dataset-size","chapter":"6 Global model","heading":"6.3 Optimal dataset size","text":"current dataset contains 314868 rows data, quite large fast efficient ML workflows. first determine performance suitable learners depends dataset size determine optimal balance model performance dataset size. words, determine point increasing dataset size (resampled fraction) improve model performance substantially anymore. Rather optimizing several steps, tune hyperparameter subsample.frac constructing GraphLearner objects mlr3 pipeline tunes dataset size. following chunk implements procedure. may take long run, ’s convenient run strictly necessary R/hyperparm_subsample_frac.R file. can use procedure test suitable ML learners, use mboost::gamboost, gbm::gbm xgboost::xgboost learners GraphLearner.can now plot results previous workflow see cross-validated model performance depends subsampled size training dataset.clear beyond 10,000 rows performance continues improve marginally untuned xgboost learners model improvement learners clearly hit plateau. , can stick resampling 10,000 rows 314868 rows original dataframe continued statistical modelling. Additionally, untuned gbm seems perform best, ’s model ’ll continue using. fair, given strong algorithmic similarity gbm xgboost, difference probably mostly consequence default parameter values mlr3, given popularity gbm ecology vs. xgboost, makes sense continue gbm.","code":"\ntask <- TaskRegrST$new(id = \"data\", backend = data, target = \"trend_long\", extra_args = list(coordinate_names = c(\"x\", \"y\")))\ntask$select(all_of(predictors))\n\nlearners <- list(\n  lrn(\"regr.gamboost\", id = \"gamboost\"),\n  lrn(\"regr.gbm\", id = \"gbm\"),\n  lrn(\"regr.xgboost\", id = \"xgboost\")\n)\nlearners_ids <- sapply(learners, function(x) x$id)\n\ngr_subsample <- po(\"subsample\") %>>%\n  po(\"branch\", options = learners_ids) %>>%\n  gunion(lapply(learners, po)) %>>%\n  po(\"unbranch\")\n\ngrlrn_subsample <- GraphLearner$new(gr_subsample)\n\nmin_nrows <- 100\nmax_nrows <- 50000\n\nmin_nrows_s <- log10(min_nrows) / log10(2)\nmax_nrow_s <- log10(max_nrows) / log10(2)\n\nps_subsample <- ParamSet$new(list(\n  ParamDbl$new(\"subsample.frac\", lower = min_nrows_s, upper = max_nrow_s),\n  ParamFct$new(\"branch.selection\", levels = learners_ids)\n))\n\n# Distribution of subsample.frac in grid can be visualised as follows\n# x <- seq(from = min_nrows_s, to = max_nrow_s, length.out = 20)\n# y <- 2^x\n# plot(x, y)\n# Beware: division by nrow(data) has to be hard-coded in the function below, somehow...\n\nps_subsample$trafo <- function(x, param_set) {\n  x$subsample.frac <- (2^x$subsample.frac) / 314868\n  return(x)\n}\n\nresample_inner <- rsmp(\"cv\", folds = 5)\nresample_outer <- rsmp(\"cv\", folds = 5)\nmeasure <- msr(\"regr.rmse\")\nterminator <- trm(\"none\")\ntuner <- tnr(\"grid_search\", resolution = 20)\n\nat <- AutoTuner$new(\n  learner = grlrn_subsample,\n  resampling = resample_inner,\n  measure = measure,\n  search_space = ps_subsample,\n  terminator = terminator,\n  tuner = tuner,\n  store_tuning_instance = TRUE,\n  store_benchmark_result = TRUE\n)\n\nfuture::plan(\"multisession\", workers = 3)\nrr <- resample(task = task, learner = at, resampling = resample_outer, store_models = TRUE)\n\nsaveRDS(as.data.table(rr), file = \"data/processed/rr_dataset_size.RDS\")\n\nrr_data <- bind_rows(lapply(rr$learners, function(x) x$model$tuning_instance$archive$data()))\nsaveRDS(rr_data, file = \"data/processed/rr_dataset_size_df.RDS\")\nif (!exists(\"rr_data\")) rr_data <- readRDS(\"data/processed/rr_dataset_size_df.RDS\")\n\nrr_data %>%\n  group_by(branch.selection, subsample.frac) %>%\n  summarise(mean_rmse = mean(regr.rmse),\n            q05 = quantile(regr.rmse, 0.05),\n            q95 = quantile(regr.rmse, 0.95),\n            .groups = \"drop_last\") %>%\n  ungroup() %>%\n  mutate(nrows = 2^subsample.frac) %>%\n  rename(Learner = branch.selection) %>%\n  ggplot(aes(color = Learner, fill = Learner)) +\n  geom_path(aes(x = nrows, y = mean_rmse)) +\n  geom_ribbon(aes(x = nrows, ymin = q05, ymax = q95), alpha = 0.5) +\n  scale_x_continuous(trans = \"log10\", breaks = c(100, 500, 1000, 5000, 10000, 50000)) +\n  labs(x = \"Subsample size (# rows)\", y = \"Model RMSE\")\nnrow_subsample <- 10000"},{"path":"global-model.html","id":"modeling-assemblage-trends","chapter":"6 Global model","heading":"6.4 Modeling assemblage trends","text":"can now finally start model long-term assemblage trends using 10^{4}-row subsample original dataset. use gamboost model strikes balance predictive accuracy interpretability, without introducing lot ‘jaggedness’ boosted regression trees (e.g. gbm xgboost) hamper interpretability unfamiliar data.","code":""},{"path":"global-model.html","id":"data-filtering","chapter":"6 Global model","heading":"6.4.1 Data filtering","text":"Exploratory modeling showed model errors largest Sahara. species included assemblage trends inhabit area, assemblage trend also least reliable (.e. composed population trends species). thus makes sense exclude areas. set minimum number species contribute assemblage trend >5 limit analysis strictly areas south Sahara, Afrotropic realm ecoregion dataset. illustrate , let’s plot number species included assemblage trends.","code":"\nset.seed(42)\ndata %>%\n  slice_sample(n = nrow_subsample) %>% \n  mutate(included = if_else((count_long > 5 & Afrotropic == 1), 1, 0, 0)) %>%\n  as.data.frame() -> data_subset\n\nxlim <- c(-20, 60)\nylim <- c(-40, 40)\nclim <- c(min(data_subset$count_long), max(data_subset$count_long))\n\nggplot(data_subset, aes(x = x, y = y, color = count_long)) +\n  geom_point() +\n  scale_color_viridis_c(limits = clim) +\n  labs(subtitle = \"Original data\",\n       x = \"Longitude\", y = \"Latitude\", color = \"# species\") +\n  theme(legend.position = \"bottom\") +\n  coord_fixed(xlim = xlim, ylim = ylim) -> original\n\ndata_subset %>%\n  filter(included == 1) %>%\n  ggplot(aes(x = x, y = y, color = count_long)) +\n  geom_point() +\n  scale_color_viridis_c(limits = clim) +\n  labs(subtitle = \"Filtered data\",\n       x = \"Longitude\", y = \"Latitude\", color = \"# species\") +\n  theme(legend.position = \"bottom\") +\n  coord_fixed(xlim = xlim, ylim = ylim) -> filtered\n\noriginal + filtered + plot_annotation(title = \"Species in long-term assemblage trend\") +\n  plot_layout(guides = \"collect\") & theme(legend.position = \"bottom\")"},{"path":"global-model.html","id":"training-boosted-gams","chapter":"6 Global model","heading":"6.4.2 Training boosted GAMs","text":"training boosted GAMs (implemented mboost) go follows:train models predicting long term assemblage trends using long-term (linear) trends environmental predictors environmental predictability (model residuals harmonic regression).determine optimal number boosting iterations using 10-fold cross-validation, implemented cvrisk function, varying number boosts 250 30000.calculate autocovariate residuals correct (strong) effects spatial autocorrelation,4 violates independence assumption regression.retrain model now whilst including residual autocovariate parameter., , determine optimal number boosting iterations new models. likely differ much previous optimum, may bit lower faster convergence due lower spatial autocorrelation.Let’s start training models.","code":"\nset.seed(42)\ndata %>%\n  filter(count_long > 5,\n         Afrotropic == 1) %>%\n  slice_sample(n = nrow_subsample) %>%\n  as.data.frame() -> data_subset\n\nsaveRDS(data_subset, file = \"data/processed/data_subset.RDS\")\n\nmodel_formula <- function(predictors, response, rac = TRUE) {\n  formula <- as.formula(paste0(response, \" ~ \", paste0(\"bbs(\", predictors, \")\", collapse = \" + \")))\n  return(formula)\n}\n\nformula_trends <- model_formula(predictors_trends, \"trend_long\")\nformula_resids <- model_formula(predictors_resids, \"trend_long\")\n\nctrl <- boost_control(trace = FALSE, mstop = 10000)\nmod_trends <- gamboost(formula_trends, data = data_subset, family = Gaussian(), control = ctrl)\nmod_resids <- gamboost(formula_resids, data = data_subset, family = Gaussian(), control = ctrl)\n\nsaveRDS(mod_trends, file = \"data/processed/models/mod_trends.RDS\")\nsaveRDS(mod_resids, file = \"data/processed/models/mod_resids.RDS\")"},{"path":"global-model.html","id":"determine-the-optimal-number-of-boosting-iterations","chapter":"6 Global model","heading":"6.4.2.1 Determine the optimal number of boosting iterations","text":"trained models, can now determine optimal number boosting iterations. time-consuming process, chunk run default ’s probably best run cross-validation procedure separately dedicated R/hyperparm_mboost_mstop.R script.can load results plot outputs.can see cross-validated models seem show stagnating model improvement beyond 10000 boosts, optimum mostly reached 30000 boosts. Given stagnating improvement, limited compute time need optimize predictive performance ad infinitum, limit number boosts 10000.","code":"\ngrid <- seq(from = 250, to = 30000, by = 250)\ncv10f_trends <- cv(model.weights(mod_trends), type = \"kfold\")\ncvm_trends <- cvrisk(mod_trends, folds = cv10f_trends, grid = grid)\nsaveRDS(cvm_trends, file = \"data/processed/models/cvm_trends.RDS\")\n\ncv10f_resids <- cv(model.weights(mod_resids), type = \"kfold\")\ncvm_resids <- cvrisk(mod_resids, folds = cv10f_resids, grid = grid)\nsaveRDS(cvm_resids, file = \"data/processed/models/cvm_resids.RDS\")\ncvm_trends <- readRDS(\"data/processed/models/cvm_trends.RDS\")\ncvm_resids <- readRDS(\"data/processed/models/cvm_resids.RDS\")\n\nplot_cvm <- function(cvm, plot_id = \"\") {\n  m <- cvm\n  class(m) <- NULL\n  as.data.frame(m) %>%\n    rownames_to_column(var = \"fold\") %>%\n    pivot_longer(-c(fold), names_to = \"boosts\", values_to = \"risk\") %>%\n    mutate(boosts = as.numeric(boosts),\n           fold = as.factor(fold)) %>%\n    identity() %>%\n    ggplot(aes(x = boosts, y = risk, group = fold, color = fold)) +\n      geom_line() +\n      labs(title = paste0(attr(cvm, \"type\"), \": \", plot_id), x = \"boosts (mstop)\", y = attr(cvm, \"risk\"))\n}\nplot_cvm_trends <- plot_cvm(cvm_trends, \"trends\")\nplot_cvm_resids <- plot_cvm(cvm_resids, \"resids\")\n\nplot_cvm_trends + plot_cvm_resids + plot_layout(guides = \"collect\") & theme(legend.position = \"bottom\")"},{"path":"global-model.html","id":"correct-for-spatial-autocorrelation","chapter":"6 Global model","heading":"6.4.2.2 Correct for spatial autocorrelation","text":"quick plot model residuals show strong spatial autocorrelation residuals, violating independence assumption regression modelling.’s need even quantify spatial autocorrelation (SAC) residuals , ’s obvious. correct using residual autocovariate method introduced Crase et al. 4. calculate autocovariate residuals using neighborhood radius 100 kilometers. radius optimized reflect actual SAC distances dataset, now seems sufficient dramatically reduce residual SAC.chunk may throw warnings points within 100 kilometers points, certainly many points dataset, can accept autocovariates accurate others.Now add calculated autocovariates residuals earlier dataset retrain models.now let’s reassess residual autocorrelation retrained model. went well, visibly substantially less .\nmuch better!","code":"\nif (!exists(\"mod_trends\")) mod_trends <- readRDS(\"data/processed/models/mod_trends.RDS\")\nif (!exists(\"mod_resids\")) mod_resids <- readRDS(\"data/processed/models/mod_resids.RDS\")\ndata_subset$norac_trends <- resid(mod_trends)\ndata_subset$norac_resids <- resid(mod_resids)\n\ndata_subset %>%\n  dplyr::select(x, y, norac_trends, norac_resids) %>%\n  rename(c(Predictability = norac_resids, Trends = norac_trends)) %>%\n  pivot_longer(-c(x, y), names_to = \"model\", values_to = \"residuals\") %>%\n  ggplot(aes(x = x, y = y, color = residuals)) +\n  geom_point() +\n  scale_color_gradient2() +\n  coord_fixed() +\n  facet_wrap(vars(model)) +\n  labs(title = \"Spatial pattern of model residuals\", x = \"Longitude\", y = \"Latitude\", color = \"Residual\")\nneighborhood_dist <- 100  # Kilometers if longlat = TRUE\nacov_trends <- autocov_dist(resid(mod_trends), as.matrix(cbind(data_subset$x, data_subset$y)), longlat = TRUE, \n                            nbs = neighborhood_dist, zero.policy = TRUE)## Warning in autocov_dist(resid(mod_trends), as.matrix(cbind(data_subset$x, : With\n## value 100 some points have no neighbours## Warning in nb2listw(nb, glist = gl, style = style, zero.policy = zero.policy):\n## zero sum general weights\nacov_resids <- autocov_dist(resid(mod_resids), as.matrix(cbind(data_subset$x, data_subset$y)), longlat = TRUE,\n                            nbs = neighborhood_dist, zero.policy = TRUE)## Warning in autocov_dist(resid(mod_resids), as.matrix(cbind(data_subset$x, : With\n## value 100 some points have no neighbours\n\n## Warning in autocov_dist(resid(mod_resids), as.matrix(cbind(data_subset$x, : zero\n## sum general weights\ndata_subset$autocov_trends <- acov_trends\ndata_subset$autocov_resids <- acov_resids\n\nformula_rac <- function(formula, var) {\n  as.formula(paste0(paste(formula[2], formula[3], sep = \" ~ \"), \" + bbs(\", var, \")\"))\n}\n\nformula_trends <- formula_rac(formula_trends, \"autocov_trends\")\nformula_resids <- formula_rac(formula_resids, \"autocov_resids\")\n\nctrl <- boost_control(trace = FALSE, mstop = 10000)\nmod_trends_rac <- gamboost(formula_trends, data = data_subset, family = Gaussian(), control = ctrl)\nmod_resids_rac <- gamboost(formula_resids, data = data_subset, family = Gaussian(), control = ctrl)\nsaveRDS(mod_trends_rac, file = \"data/processed/models/mod_trends_rac.RDS\")\nsaveRDS(mod_resids_rac, file = \"data/processed/models/mod_resids_rac.RDS\")\nif (!exists(\"mod_trends_rac\")) mod_trends_rac <- readRDS(\"data/processed/models/mod_trends_rac.RDS\")\nif (!exists(\"mod_resids_rac\")) mod_resids_rac <- readRDS(\"data/processed/models/mod_resids_rac.RDS\")\ndata_subset$rac_trends <- resid(mod_trends_rac)\ndata_subset$rac_resids <- resid(mod_resids_rac)\n\ndata_subset %>%\n  dplyr::select(x, y, rac_trends, rac_resids) %>%\n  rename(c(Predictability = rac_resids, Trends = rac_trends)) %>%\n  pivot_longer(-c(x, y), names_to = \"model\", values_to = \"residuals\") %>%\n  ggplot(aes(x = x, y = y, color = residuals)) +\n  geom_point() +\n  scale_color_gradient2() +\n  coord_fixed() +\n  facet_wrap(vars(model)) +\n  labs(title = \"Spatial pattern of model residuals\", subtitle = \"after including residual autocovariates\",\n       x = \"Longitude\", y = \"Latitude\", color = \"Residual\")"},{"path":"global-model.html","id":"quantifying-residual-autocorrelation","chapter":"6 Global model","heading":"6.4.2.3 Quantifying residual autocorrelation","text":"Now good moment quantify residual autocorrelation (RSAC) model. calculating Moran’s across number distance classes (8) using sp.correlogram function spdep package. computationally intensive, run calculation chunk save results fast plotting knitting document.can now plot RSAC correlograms.Adding autocovariate residuals seems helped lot counter residual spatial autocorrelation. ’s possible can improved tweaking radius neighborhood autocovariate calculated, ’s tweaking can later.","code":"\nnclass <- 8  # Number of distance classes\nneighbors <- dnearneigh(as.matrix(cbind(data_subset$x, data_subset$y)), d1 = 0, d2 = neighborhood_dist, longlat = TRUE)\n\nspc_norac_trends <- sp.correlogram(neighbors, data_subset$norac_trends, order = nclass, method = \"I\", zero.policy = TRUE)\nspc_norac_resids <- sp.correlogram(neighbors, data_subset$norac_resids, order = nclass, method = \"I\", zero.policy = TRUE)\nspc_rac_trends <- sp.correlogram(neighbors, data_subset$rac_trends, order = nclass, method = \"I\", zero.policy = TRUE)\nspc_rac_resids <- sp.correlogram(neighbors, data_subset$rac_resids, order = nclass, method = \"I\", zero.policy = TRUE)\n\nsaveRDS(spc_norac_trends, file = \"data/processed/models/spc_norac_trends.RDS\")\nsaveRDS(spc_norac_resids, file = \"data/processed/models/spc_norac_resids.RDS\")\nsaveRDS(spc_rac_trends, file = \"data/processed/models/spc_rac_trends.RDS\")\nsaveRDS(spc_rac_resids, file = \"data/processed/models/spc_rac_resids.RDS\")\nif (!exists(\"spc_norac_trends\")) spc_norac_trends <- readRDS(\"data/processed/models/spc_norac_trends.RDS\")\nif (!exists(\"spc_norac_resids\")) spc_norac_resids <- readRDS(\"data/processed/models/spc_norac_resids.RDS\")\nif (!exists(\"spc_rac_trends\")) spc_rac_trends <- readRDS(\"data/processed/models/spc_rac_trends.RDS\")\nif (!exists(\"spc_rac_resids\")) spc_rac_resids <- readRDS(\"data/processed/models/spc_rac_resids.RDS\")\n\npar(mfrow = c(2, 2))\nplot(spc_norac_trends, main = \"RSAC Trends mdl\")\nplot(spc_norac_resids, main = \"RSAC Predictability mdl\")\nplot(spc_rac_trends, main = \"RSAC Trends RAC mdl\")\nplot(spc_rac_resids, main = \"RSAC Predictability RAC mdl\")"},{"path":"global-model.html","id":"model-outputs","chapter":"6 Global model","heading":"6.4.3 Model outputs","text":"","code":""},{"path":"global-model.html","id":"model-performance","chapter":"6 Global model","heading":"6.4.3.1 Model performance","text":"keep simple, stick good ol’ RMSE % deviance explained compare performance models.","code":"\nperf_metrics <- function(actual, models) {\n  rmse <- lapply(models, function(x) rmse(actual, predict(x)))\n  deviance_explained <- lapply(models, function(x) (1 - (tail(risk(x), 1) / head(risk(x), 1))) * 100)\n  m <- rbind(rmse, deviance_explained)\n  mode(m) <- \"numeric\"\n  m\n}\n\npm <- as.data.frame(perf_metrics(data_subset$trend_long, list(mod_trends, mod_resids, mod_trends_rac, mod_resids_rac)))\ncolnames(pm) <- c(\"mod_trends\", \"mod_resids\", \"mod_trends_rac\", \"mod_resids_rac\")\nrownames(pm) <- c(\"RMSE\", \"% Deviance explained\")\npm"},{"path":"global-model.html","id":"variable-importance","chapter":"6 Global model","heading":"6.4.3.2 Variable importance","text":"can quantify importance variables within model using varimp function mboost package. returns variable importance, measure total improvement model deviance variable responsible . weighted number times predictor selected boosted models.","code":""},{"path":"global-model.html","id":"trends-models","chapter":"6 Global model","heading":"6.4.3.2.1 Trends models","text":"","code":"\nplot(varimp(mod_trends), main = \"Varimp Trends mdl\")\nplot(varimp(mod_trends_rac), main = \"Varimp Trends RAC mdl\")"},{"path":"global-model.html","id":"predictability-models","chapter":"6 Global model","heading":"6.4.3.2.2 Predictability models","text":"","code":"\nplot(varimp(mod_resids), main = \"Varimp Predictability mdl\")\nplot(varimp(mod_resids_rac), main = \"Varimp Predictability RAC mdl\")"},{"path":"global-model.html","id":"partialmarginal-effects","chapter":"6 Global model","heading":"6.4.3.3 Partial/Marginal Effects","text":", finally, can look modelled effects predictors long-term assemblage trends. first compare output original models.","code":""},{"path":"global-model.html","id":"partial-effects-original-models","chapter":"6 Global model","heading":"6.4.3.3.1 Partial effects original models","text":"","code":"\npar(mfrow = c(2, 3))\nplot(mod_trends)\n\npar(mfrow = c(2, 3))\nplot(mod_resids)"},{"path":"global-model.html","id":"partial-effects-rac-models","chapter":"6 Global model","heading":"6.4.3.3.2 Partial effects RAC models","text":"","code":"\npar(mfrow = c(2, 3))\nplot(mod_trends_rac)\npar(mfrow = c(2, 3))\nplot(mod_resids_rac)"},{"path":"references.html","id":"references","chapter":"7 References","heading":"7 References","text":"1. Bird species distribution maps world. Version 2019.1 (2019).2. Storchová, L., Hořák, D. (2018). Life-history characteristics european birds. Global Ecology Biogeography 27, 400–406.3. Beresford, .E., Sanderson, F.J., Donald, P.F., Burfield, .J., Butler, ., Vickery, J.., Buchanan, G.M. (2018). Phenology climate change africa decline afro-palearctic migratory bird populations. Remote Sensing Ecology Conservation 5, 55–69.4. Crase, B., Liedloff, .C., Wintle, B.. (2012). new method dealing residual spatial autocorrelation species distribution models. Ecography 35, 879–888.","code":""}]
